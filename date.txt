typedef bool (*action_t)(const char *s, const char **end, cjson_callback_t callback);


static rule_t transitions[S_COUNT][L_COUNT] = {
//                  L_HNAME                 L_STR                   L_EMPTY_STR             L_EOF

/*S_BEGIN*/         {{S_HNAME, valid_h}, {S_ERR, NULL},             {S_ERR,  NULL},         {S_ERR, NULL}},
/*S_HNAME*/         {{S_ERR,  NULL},     {S_HVALUE, str_check},     {S_ERR,  NULL},         {S_ERR, NULL}},
/*S_HVALUE*/        {{S_HNAME, valid_h}, {S_HVALUE, str_check},     {S_HEND, part_begin},   {S_ERR, NULL}},
/*S_HEND*/          {{S_PART, NULL},     {S_PART,   str_check},     {S_HEND, part_begin},   {S_END, finish}},

/*S_PART*/          {{S_PART, NULL},     {S_PART,   str_check},     {S_PART, NULL},         {S_END, finish}},
/*S_END*/           {{S_ERR,  NULL},     {S_ERR, NULL},             {S_ERR,  NULL},         {S_ERR, NULL}}
};

int valid_h(char **header, callback_t callback) {
    char *correct_header = calloc(sizeof *header, sizeof(char));
    for (int i = 0; *header[i] != '\0'; ++i) {
        if (isalpha(*header[i])) {
            correct_header[i] = tolower(*header[i]);
        }
    }
    free(*header);
    *header = correct_header;
    switch (*header) {
        case (H_FROM: {
            break;
        }
        case (H_TO): {
            break;
        }
        case (H_DATE): {
            break;
        }
        case (H_CONTENT_TYPE): {
            break;
        }
        default: {

        }
    }
}

int write_out(char **header, callback_t callback) {
    callback(*header);
}

int part_count(char **header, callback_t callback) {
    callback(*header);
}
